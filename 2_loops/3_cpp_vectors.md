# Векторы в C++

## Введение
- Вектор (`std::vector`) - контейнер для хранения набора значений одного типа
- Позволяет хранить элементы любого типа: числа, строки, другие контейнеры
- Поддерживает динамическое изменение размера

## Создание вектора
```cpp
#include <vector>

// Пустой вектор
std::vector<int> numbers;

// Вектор заданного размера (заполнен нулями)
std::vector<int> seven_zeros(7);

// Вектор с заданным размером и значением
std::vector<int> ten_fives(10, 50);

// Вектор с начальными значениями
std::vector<int> holiday{15, 100, -42, 100500};

// Копия существующего вектора
std::vector<int> copy1(holiday);
std::vector<int> copy2 = holiday;
```

## Основные операции

### Добавление и удаление элементов
```cpp
std::vector<int> numbers;

// Добавление в конец
numbers.push_back(15);
numbers.push_back(100);

// Удаление последнего элемента
numbers.pop_back();
```

### Доступ к элементам
```cpp
std::vector<int> numbers{15, 100, -42, 100500};

// По индексу
int first = numbers[0];    // 15
int third = numbers[2];    // -42

// Первый и последний элементы
int first = numbers.front();  // 15
int last = numbers.back();    // 100500
```

### Информация о векторе
```cpp
std::vector<int> numbers{15, 100, -42};

// Размер вектора
size_t size = numbers.size();  // 3

// Проверка на пустоту
bool is_empty = numbers.empty();  // false
```

## Работа с вектором в цикле
```cpp
// Чтение n строк в вектор
std::vector<std::string> lines;
int n;
std::cin >> n;

std::string line;
std::getline(std::cin, line);  // Пропускаем остаток строки

for (int i = 0; i < n; ++i) {
    std::getline(std::cin, line);
    lines.push_back(line);
}

// Вывод элементов вектора
for (size_t i = 0; i < lines.size(); ++i) {
    std::cout << lines[i] << std::endl;
}
```

## Циклы по диапазону (Range-based for)
- Позволяет итерироваться по элементам без использования индексов
- Работает только в прямом порядке
- Поддерживает изменение элементов через ссылки

```cpp
std::vector<int> numbers{4, 8, 15, 16, 23, 42};

// Простой перебор элементов
for (int item : numbers) {
    std::cout << item << std::endl;
}

// Изменение элементов через ссылку
for (int& item : numbers) {
    if (item % 2 == 0) {
        item /= 2;
    }
}

// Использование auto
for (auto& item : numbers) {
    std::cout << item << std::endl;
}
```

## Автоматический вывод типов

### Ключевое слово auto
- Позволяет компилятору самостоятельно определить тип
- Требует инициализации при объявлении
- Нельзя использовать для разных типов в одном объявлении

```cpp
// Вывод типа для простых переменных
auto i = 100;  // int
auto s = "Hello"s;  // std::string

// Вывод типа для векторов
std::vector v1{1, 2, 3, 4};  // std::vector<int>
auto v2 = v1;  // std::vector<int>

// Ошибки при использовании auto
auto x;  // Ошибка: нет инициализации
auto a = 1, b = "abc"s;  // Ошибка: разные типы
```

### Особенности вывода типов для векторов
```cpp
// Вывод типа элементов вектора
std::vector v1{"I", "love", "C++"};  // std::vector<const char*>
std::vector v2{"I"s, "love"s, "C++"s};  // std::vector<std::string>

// Использование auto в цикле по диапазону
std::vector<std::string> words{"Hello", "World"};
for (auto& word : words) {
    // word имеет тип std::string&
    word = "New " + word;
}
```

## Вложенные циклы
- Циклы можно вкладывать друг в друга
- Внутренний цикл выполняется полностью на каждой итерации внешнего

```cpp
// Приведение строк к верхнему регистру
std::vector<std::string> words{"I", "love", "C++"};
for (auto& word : words) {
    for (size_t i = 0; i < word.size(); ++i) {
        if (std::isalpha(word[i])) {
            word[i] = std::toupper(word[i]);
        }
    }
}

// Таблица умножения
for (int i = 1; i < 10; ++i) {
    for (int j = 1; j < 10; ++j) {
        std::cout << std::setw(3) << i * j;
    }
    std::cout << std::endl;
}
```

## Важные моменты
1. Индексация начинается с 0
2. Методы `front()`, `back()` и `[]` требуют наличия элементов
3. `size()` возвращает `size_t` (беззнаковый тип)
4. `push_back()` добавляет элемент в конец
5. `pop_back()` удаляет последний элемент
6. При обращении к несуществующему элементу - неопределенное поведение
7. Вектор - шаблонный тип, требует указания типа элементов
8. Можно создавать векторы любых типов, включая другие векторы
9. Конструктор по умолчанию создает пустой вектор
10. При создании вектора заданного размера элементы инициализируются значением по умолчанию
11. Цикл по диапазону удобнее обычного for при переборе элементов
12. Используйте ссылки (&) в цикле по диапазону для изменения элементов
13. auto упрощает код, но требует внимательности при использовании
14. Вложенные циклы могут значительно увеличить сложность алгоритма
15. При использовании auto для строк используйте суффикс s для std::string 