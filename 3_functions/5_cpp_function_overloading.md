# Перегрузка функций в C++

## Что такое перегрузка функций
- Позволяет определить несколько функций с одним именем, но разными параметрами (типами и/или количеством).
- Компилятор выбирает нужную функцию на основе аргументов при вызове.

## Пример перегрузки
```cpp
#include <iostream>
using namespace std::literals;

void Print(int x) {
    std::cout << "int "s << x << std::endl;
}
void Print(double x) {
    std::cout << "double "s << x << std::endl;
}
void Print(const std::string& s) {
    std::cout << "string "s << s << std::endl;
}

int main() {
    Print(3);        // int 3
    Print(2.6);      // double 2.6
    Print("Hello"s); // string Hello
}
```

## Зачем нужна перегрузка
- Позволяет использовать одно имя для функций, работающих с разными типами.
- Повышает читаемость и удобство использования кода.
- В C перегрузки нет, поэтому часто используют разные имена (например, abs, fabs, fabsf).

## Как можно перегружать
- По количеству аргументов
- По типу аргументов
- По наличию значений по умолчанию
- Нельзя перегружать только по имени параметра или только по возвращаемому типу

```cpp
void Print(int value);           // OK
void Print(double value);        // OK
void Print(int value, int base); // OK
// void Print(int x);           // Ошибка: уже есть Print(int)
// double Print(int value);     // Ошибка: только возвращаемый тип отличается
```

## Как компилятор выбирает функцию
1. Сначала ищет функции с подходящим количеством аргументов (учитывает значения по умолчанию)
2. Затем выбирает наиболее точное совпадение типов (ранги преобразований):
   - Полное совпадение
   - Расширение типа (например, float → double)
   - Преобразование типов (например, int → double)
3. Если есть неоднозначность — ошибка компиляции

## Пример выбора перегруженной функции
```cpp
void Print(double x, double y) { ... }
void Print(double x) { ... }
void Print(int x) { ... }
void Print(double x, int y) { ... }
void Print(int x, double y) { ... }
void Print(int x, int y) { ... }

int main() {
    Print(3.5, 4.2); // two doubles
    Print(2.6);      // double
    Print(4);        // int
    Print(2, 2.6);   // int and double
    Print(3.15, 1);  // double and int
    Print(7, 7);     // two ints
}
```

## Неявные преобразования
- Компилятор может преобразовать типы аргументов, если нет точного совпадения
- float → double, char → int, unsigned → int/double и др.
- Если есть несколько кандидатов с одинаковым рангом преобразования — ошибка

```cpp
unsigned x = 42;
// Print(x); // Ошибка: Print(int) или Print(double)?
Print(static_cast<int>(x));    // Явно вызываем Print(int)
Print(static_cast<double>(x)); // Явно вызываем Print(double)
```

## Ограничения перегрузки
- Нельзя перегружать только по возвращаемому типу
- Имена параметров не учитываются

```cpp
int Convert(int x) { return x; }
// double Convert(int x) { return y; } // Ошибка
```

## Пример с дефолтными аргументами
```cpp
void Print(double d, int n = 3) { std::cout << "d" << n; }
void Print(float f, const std::string& arg = "!"s) { std::cout << "f" << arg; }
void Print(int i = 5, int n = 3) { std::cout << "i" << i << "," << n; }

int main() {
    Print(2.3f, 42); // d42
    Print(7);        // i7,3
    Print(3.5f);     // f!
    Print(2, "?"s);  // f?
}
```

## Важные моменты
1. Перегружать можно только по типу и количеству аргументов
2. Возвращаемый тип не влияет на выбор функции
3. Значения по умолчанию расширяют возможности перегрузки
4. Неявные преобразования типов могут привести к неоднозначности
5. Для разрешения неоднозначности используйте явное приведение типов
6. Перегрузка повышает читаемость и удобство кода 