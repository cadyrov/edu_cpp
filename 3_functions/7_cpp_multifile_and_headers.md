# Многофайловые программы и заголовочные файлы в C++

## Зачем нужны многофайловые программы
- Позволяют разбивать большие проекты на отдельные логические части
- Упрощают навигацию и поддержку кода
- Позволяют нескольким разработчикам работать над разными частями программы

## Этапы сборки программы
1. **Компиляция** — каждый исходный файл (.cpp) компилируется независимо в объектный файл (.o/.obj)
2. **Компоновка (линковка)** — объектные файлы объединяются в итоговую программу

## Единица трансляции
- Каждый .cpp-файл — отдельная единица трансляции
- Заголовочные файлы (.h/.hpp) не образуют единицу трансляции, а просто подставляются в .cpp-файлы через #include

## Пример структуры
```
main.cpp
factorial.cpp
factorial.h
```

- В main.cpp — объявление и вызов функции Factorial
- В factorial.cpp — определение функции Factorial
- В factorial.h — объявление функции Factorial

## Пример: объявление и определение в разных файлах
**factorial.h**
```cpp
#pragma once
int Factorial(int n);
```

**factorial.cpp**
```cpp
#include "factorial.h"
int Factorial(int n) {
    int f = 1;
    for (int i = 2; i <= n; ++i) {
        f *= i;
    }
    return f;
}
```

**main.cpp**
```cpp
#include <iostream>
#include "factorial.h"
int main() {
    std::cout << Factorial(3) << std::endl;
}
```

## Как работает #include
- Директива #include просто подставляет содержимое заголовочного файла в место подключения
- #include <...> — для стандартных заголовков, #include "..." — для пользовательских

## #pragma once
- Защищает от повторного включения заголовочного файла
- Помещайте в начало каждого .h-файла

```cpp
#pragma once
```

## Что подключать в заголовочных файлах
- Только то, что нужно для объявления функций и типов (например, <vector> для std::vector)
- Не подключайте лишние заголовки — это замедляет компиляцию

## Где указывать значения по умолчанию
- Только в объявлении функции (обычно в .h-файле), не в определении

## Пример с несколькими файлами
**notation.h**
```cpp
#pragma once
#include <string>
int StringToNumber(const std::string& s, bool& was_error, int base = 10);
std::string NumberToString(int number, bool& was_error, int base = 10);
std::string ConvertNotation(const std::string& src_number, int src_base, int dst_base);
```

**notation.cpp**
```cpp
#include "notation.h"
int StringToNumber(const std::string& s, bool& was_error, int base) { /* ... */ }
// ...
```

## Вспомогательные функции
- Не выносите объявления вспомогательных функций в .h, если они нужны только внутри одного .cpp-файла

## Пример правильного подключения
**print.h**
```cpp
#pragma once
#include <vector>
void Print(const std::vector<int>& numbers);
```
**print.cpp**
```cpp
#include "print.h"
#include <iostream>
#include <string>
using namespace std::literals;
// ...
```

## Важные моменты
1. Для совместно используемых функций создавайте .h-файлы с объявлениями
2. В .cpp-файлах подключайте соответствующие .h-файлы
3. Не дублируйте объявления функций вручную — используйте заголовочные файлы
4. Используйте #pragma once для защиты от повторного включения
5. Не подключайте заголовочный файл сам в себя
6. Значения по умолчанию указывайте только в .h-файле
7. Вспомогательные функции оставляйте только в .cpp-файле
8. Заголовочный файл — это интерфейс, .cpp — реализация 