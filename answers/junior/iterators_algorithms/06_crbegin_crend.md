# Что такое crbegin() и crend()?

## Вопрос
Что такое `crbegin()` и `crend()`?

## Ответ
`crbegin()` и `crend()` - это методы контейнеров STL, которые возвращают константные обратные итераторы:
- `crbegin()` возвращает константный обратный итератор на последний элемент
- `crend()` возвращает константный обратный итератор на позицию перед первым элементом

## Примеры кода

### Правильное использование
```cpp
#include <vector>
#include <list>
#include <iostream>

int main() {
    // Использование с vector
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // Обратный обход с использованием константных обратных итераторов
    for (auto it = vec.crbegin(); it != vec.crend(); ++it) {
        std::cout << *it << " "; // Выведет: 5 4 3 2 1
        // *it = 10; // Ошибка компиляции: нельзя изменять значение через константный итератор
    }
    std::cout << std::endl;

    // Использование с const контейнером
    const std::list<int> lst = {1, 2, 3, 4, 5};
    for (auto it = lst.crbegin(); it != lst.crend(); ++it) {
        std::cout << *it << " "; // Выведет: 5 4 3 2 1
    }
    std::cout << std::endl;

    // Использование в алгоритмах
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    auto it = std::find(numbers.crbegin(), numbers.crend(), 3);
    if (it != numbers.crend()) {
        std::cout << "Found: " << *it << std::endl;
    }

    return 0;
}
```

### Неправильное использование
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // ❌ Неправильно: попытка изменить значение через константный обратный итератор
    auto it = vec.crbegin();
    *it = 10; // Ошибка компиляции: нельзя изменять значение через константный итератор
    
    // ❌ Неправильно: использование константного обратного итератора для неконстантного контейнера
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    auto crit = numbers.crbegin();
    numbers.push_back(6); // Инвалидирует итератор
    std::cout << *crit << std::endl; // Неопределенное поведение
    
    // ❌ Неправильно: смешивание разных типов итераторов
    auto rit = vec.rbegin();
    auto crit1 = vec.crbegin();
    if (rit == crit1) { // Ошибка компиляции: разные типы итераторов
        std::cout << "Equal" << std::endl;
    }
    
    return 0;
}
```

## Комментарии
1. Константные обратные итераторы сочетают свойства константных и обратных итераторов
2. `crbegin()/crend()` особенно полезны при работе с константными контейнерами в обратном порядке
3. Константные обратные итераторы могут быть использованы в алгоритмах, которые только читают данные
4. При использовании `auto` с константными обратными итераторами тип будет выведен как `const_reverse_iterator`
5. Константные обратные итераторы могут быть инвалидированы при изменении контейнера
6. В современном C++ предпочтительнее использовать `const auto&` в range-based for loop с `rbegin()/rend()`
7. Константные обратные итераторы обеспечивают безопасность при работе с данными
8. При работе с константными обратными итераторами компилятор предотвращает случайное изменение данных 