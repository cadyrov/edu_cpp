# Что такое `deque`?

## Ответ
`std::deque` (double-ended queue) - это двусторонняя очередь, которая позволяет эффективно добавлять и удалять элементы как в начале, так и в конце контейнера.

Основные характеристики:
1. Произвольный доступ к элементам (O(1))
2. Вставка и удаление в начале и конце - O(1)
3. Вставка и удаление в середине - O(n)
4. Элементы хранятся в нескольких блоках памяти
5. Итераторы могут стать невалидными после вставки/удаления

## Примеры кода

### Правильное использование

```cpp
// Создание и инициализация deque
std::deque<int> dq = {1, 2, 3, 4, 5};

// Добавление элементов
dq.push_front(0);  // В начало
dq.push_back(6);   // В конец

// Доступ к элементам
int first = dq.front();  // Первый элемент
int last = dq.back();    // Последний элемент
int third = dq[2];       // Произвольный доступ

// Удаление элементов
dq.pop_front();  // Удаление первого элемента
dq.pop_back();   // Удаление последнего элемента

// Вставка в произвольную позицию
auto it = dq.begin() + 2;
dq.insert(it, 10);  // Вставка перед третьим элементом

// Размер и емкость
size_t size = dq.size();
bool empty = dq.empty();
```

### Неправильное использование

```cpp
// Неправильно: частое использование insert в середину
std::deque<int> dq = {1, 2, 3, 4, 5};
for (int i = 0; i < 1000; ++i) {
    dq.insert(dq.begin() + dq.size()/2, i);  // O(n) операция
}

// Правильно: использование list для частых вставок в середину
std::list<int> lst = {1, 2, 3, 4, 5};
for (int i = 0; i < 1000; ++i) {
    auto it = lst.begin();
    std::advance(it, lst.size()/2);
    lst.insert(it, i);  // O(1) операция
}

// Неправильно: предположение о валидности итераторов
std::deque<int> dq = {1, 2, 3, 4, 5};
auto it = dq.begin() + 2;
dq.push_back(6);  // Итератор может стать невалидным
*it;  // Неопределенное поведение
```

## Рекомендации по использованию

1. Используйте `std::deque` когда:
   - Нужны частые операции в начале и конце контейнера
   - Требуется произвольный доступ к элементам
   - Размер контейнера может значительно меняться
   - Не критична валидность итераторов

2. Не используйте `std::deque` когда:
   - Нужны частые вставки/удаления в середине контейнера
   - Важна компактность в памяти
   - Критична валидность итераторов
   - Нужна максимальная производительность при последовательном доступе

## Особенности реализации

```cpp
// Упрощенная структура deque
template<typename T>
class Deque {
    struct Block {
        T* data;
        size_t size;
        Block* next;
        Block* prev;
    };
    
    Block* first_block;
    Block* last_block;
    size_t block_size;
    size_t total_size;
};

// Пример вставки в начало
template<typename T>
void Deque<T>::push_front(const T& value) {
    if (first_block->size == 0) {
        // Создание нового блока
        Block* new_block = new Block{new T[block_size], 0, first_block, nullptr};
        first_block->prev = new_block;
        first_block = new_block;
    }
    
    // Сдвиг элементов и вставка нового
    for (size_t i = first_block->size; i > 0; --i) {
        first_block->data[i] = first_block->data[i-1];
    }
    first_block->data[0] = value;
    first_block->size++;
    total_size++;
}
``` 