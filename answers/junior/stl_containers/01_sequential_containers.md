# Какие последовательные контейнеры есть в STL?

## Ответ
В STL (Standard Template Library) существует несколько последовательных контейнеров:

1. `std::vector` - динамический массив с произвольным доступом
2. `std::array` - статический массив фиксированного размера
3. `std::deque` - двусторонняя очередь
4. `std::list` - двусвязный список
5. `std::forward_list` - односвязный список

## Примеры кода

### Правильное использование

```cpp
// vector - динамический массив
std::vector<int> vec = {1, 2, 3, 4, 5};
vec.push_back(6);  // Добавление элемента в конец

// array - статический массив
std::array<int, 5> arr = {1, 2, 3, 4, 5};
// arr.push_back(6);  // Ошибка! Размер фиксирован

// deque - двусторонняя очередь
std::deque<int> dq = {1, 2, 3};
dq.push_front(0);  // Добавление в начало
dq.push_back(4);   // Добавление в конец

// list - двусвязный список
std::list<int> lst = {1, 2, 3};
lst.push_front(0);
lst.push_back(4);

// forward_list - односвязный список
std::forward_list<int> flst = {1, 2, 3};
flst.push_front(0);
// flst.push_back(4);  // Ошибка! Нет доступа к концу списка
```

### Неправильное использование

```cpp
// Неправильно: использование vector для частых вставок в начало
std::vector<int> vec = {1, 2, 3};
for (int i = 0; i < 1000; ++i) {
    vec.insert(vec.begin(), i);  // Неэффективно! O(n) операция
}

// Правильно: использовать deque для частых вставок в начало
std::deque<int> dq = {1, 2, 3};
for (int i = 0; i < 1000; ++i) {
    dq.push_front(i);  // Эффективно! O(1) операция
}

// Неправильно: использование list для произвольного доступа
std::list<int> lst = {1, 2, 3, 4, 5};
auto it = lst.begin() + 3;  // Ошибка! Нет оператора +

// Правильно: использовать vector для произвольного доступа
std::vector<int> vec = {1, 2, 3, 4, 5};
auto it = vec.begin() + 3;  // Корректно
```

## Рекомендации по выбору контейнера

1. `std::vector` - используйте когда:
   - Нужен произвольный доступ к элементам
   - Размер контейнера может меняться
   - Частые операции в конце контейнера

2. `std::array` - используйте когда:
   - Размер контейнера известен на этапе компиляции
   - Нужен произвольный доступ
   - Размер не будет меняться

3. `std::deque` - используйте когда:
   - Нужны частые вставки/удаления как в начале, так и в конце
   - Нужен произвольный доступ (но менее эффективный чем у vector)

4. `std::list` - используйте когда:
   - Нужны частые вставки/удаления в произвольных позициях
   - Не нужен произвольный доступ
   - Важна стабильность итераторов

5. `std::forward_list` - используйте когда:
   - Нужны частые вставки/удаления в произвольных позициях
   - Важна экономия памяти
   - Нужен только последовательный доступ вперед 