# Что такое `set` и `multiset`?

## Ответ
`std::set` и `std::multiset` - это ассоциативные контейнеры, которые хранят элементы в отсортированном порядке. Основное различие между ними:
- `set` хранит только уникальные элементы
- `multiset` может хранить дубликаты

Основные характеристики:
1. Элементы всегда отсортированы
2. Поиск, вставка и удаление - O(log n)
3. Элементы хранятся в виде сбалансированного дерева
4. Итераторы остаются валидными после вставки/удаления
5. Требуют, чтобы элементы поддерживали операцию сравнения

## Примеры кода

### Правильное использование

```cpp
// Создание и инициализация set
std::set<int> s = {3, 1, 4, 1, 5, 9};  // {1, 3, 4, 5, 9}

// Вставка элементов
s.insert(2);  // {1, 2, 3, 4, 5, 9}
s.insert(1);  // {1, 2, 3, 4, 5, 9} - дубликат не добавляется

// Создание и инициализация multiset
std::multiset<int> ms = {3, 1, 4, 1, 5, 9};  // {1, 1, 3, 4, 5, 9}

// Вставка элементов в multiset
ms.insert(2);  // {1, 1, 2, 3, 4, 5, 9}
ms.insert(1);  // {1, 1, 1, 2, 3, 4, 5, 9} - дубликат добавляется

// Поиск элементов
auto it = s.find(3);  // Итератор на элемент 3
if (it != s.end()) {
    std::cout << "Найден элемент: " << *it << std::endl;
}

// Удаление элементов
s.erase(3);  // Удаление элемента 3
ms.erase(1);  // Удаление всех элементов со значением 1

// Проверка наличия элемента
if (s.count(4) > 0) {
    std::cout << "Элемент 4 найден" << std::endl;
}
```

### Неправильное использование

```cpp
// Неправильно: попытка изменить элемент напрямую
std::set<int> s = {1, 2, 3, 4, 5};
auto it = s.find(3);
*it = 6;  // Ошибка! Элементы set нельзя изменять

// Правильно: удаление и вставка нового элемента
std::set<int> s = {1, 2, 3, 4, 5};
auto it = s.find(3);
s.erase(it);
s.insert(6);

// Неправильно: использование set для частых вставок/удалений
std::set<int> s;
for (int i = 0; i < 1000; ++i) {
    s.insert(i);  // O(log n) операция
    s.erase(i);   // O(log n) операция
}

// Правильно: использование vector для частых вставок/удалений
std::vector<int> v;
for (int i = 0; i < 1000; ++i) {
    v.push_back(i);  // O(1) операция
    v.pop_back();    // O(1) операция
}
```

## Рекомендации по использованию

1. Используйте `std::set` когда:
   - Нужны уникальные элементы
   - Требуется быстрый поиск элементов
   - Элементы должны быть отсортированы
   - Нужна гарантия уникальности

2. Используйте `std::multiset` когда:
   - Допустимы дубликаты
   - Требуется быстрый поиск элементов
   - Элементы должны быть отсортированы
   - Нужно хранить количество вхождений элементов

3. Не используйте `set`/`multiset` когда:
   - Нужны частые вставки/удаления
   - Требуется произвольный доступ к элементам
   - Важна компактность в памяти
   - Элементы не поддерживают сравнение

## Особенности реализации

```cpp
// Пример структуры узла красно-черного дерева
template<typename T>
struct Node {
    T data;
    Node* left;
    Node* right;
    Node* parent;
    bool is_red;
};

// Пример вставки элемента в set
template<typename T>
Node<T>* insert(Node<T>* root, const T& value) {
    if (root == nullptr) {
        return new Node<T>{value, nullptr, nullptr, nullptr, false};
    }
    
    if (value < root->data) {
        root->left = insert(root->left, value);
        root->left->parent = root;
    } else if (value > root->data) {
        root->right = insert(root->right, value);
        root->right->parent = root;
    }
    
    // Балансировка дерева
    // ...
    
    return root;
}
``` 