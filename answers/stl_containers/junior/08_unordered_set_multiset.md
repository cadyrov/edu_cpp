# Что такое `unordered_set` и `unordered_multiset`?

## Ответ
`std::unordered_set` и `std::unordered_multiset` - это ассоциативные контейнеры, которые хранят элементы в хеш-таблице. Основное различие между ними:
- `unordered_set` хранит только уникальные элементы
- `unordered_multiset` может хранить дубликаты

Основные характеристики:
1. Элементы не отсортированы
2. Поиск, вставка и удаление - O(1) в среднем
3. Элементы хранятся в хеш-таблице
4. Итераторы могут стать невалидными после вставки/удаления
5. Требуют, чтобы элементы поддерживали хеширование

## Примеры кода

### Правильное использование

```cpp
// Создание и инициализация unordered_set
std::unordered_set<int> us = {3, 1, 4, 1, 5, 9};  // {1, 3, 4, 5, 9}

// Вставка элементов
us.insert(2);  // {1, 2, 3, 4, 5, 9}
us.insert(1);  // {1, 2, 3, 4, 5, 9} - дубликат не добавляется

// Создание и инициализация unordered_multiset
std::unordered_multiset<int> ums = {3, 1, 4, 1, 5, 9};  // {1, 1, 3, 4, 5, 9}

// Вставка элементов в unordered_multiset
ums.insert(2);  // {1, 1, 2, 3, 4, 5, 9}
ums.insert(1);  // {1, 1, 1, 2, 3, 4, 5, 9} - дубликат добавляется

// Поиск элементов
auto it = us.find(3);  // Итератор на элемент 3
if (it != us.end()) {
    std::cout << "Найден элемент: " << *it << std::endl;
}

// Удаление элементов
us.erase(3);  // Удаление элемента 3
ums.erase(1);  // Удаление всех элементов со значением 1

// Проверка наличия элемента
if (us.count(4) > 0) {
    std::cout << "Элемент 4 найден" << std::endl;
}

// Резервирование места
us.reserve(1000);  // Предварительное выделение памяти
```

### Неправильное использование

```cpp
// Неправильно: предположение о порядке элементов
std::unordered_set<int> us = {1, 2, 3, 4, 5};
for (auto it = us.begin(); it != us.end(); ++it) {
    // Порядок элементов не гарантирован
    std::cout << *it << " ";
}

// Правильно: использование set для отсортированного порядка
std::set<int> s = {1, 2, 3, 4, 5};
for (auto it = s.begin(); it != s.end(); ++it) {
    // Элементы гарантированно отсортированы
    std::cout << *it << " ";
}

// Неправильно: частое изменение размера
std::unordered_set<int> us;
for (int i = 0; i < 1000; ++i) {
    us.insert(i);  // Может вызвать рехеширование
}

// Правильно: предварительное резервирование места
std::unordered_set<int> us;
us.reserve(1000);  // Предотвращает рехеширование
for (int i = 0; i < 1000; ++i) {
    us.insert(i);
}
```

## Рекомендации по использованию

1. Используйте `std::unordered_set` когда:
   - Нужны уникальные элементы
   - Требуется быстрый поиск элементов
   - Порядок элементов не важен
   - Элементы поддерживают хеширование

2. Используйте `std::unordered_multiset` когда:
   - Допустимы дубликаты
   - Требуется быстрый поиск элементов
   - Порядок элементов не важен
   - Элементы поддерживают хеширование

3. Не используйте `unordered_set`/`unordered_multiset` когда:
   - Нужен отсортированный порядок элементов
   - Важна стабильность итераторов
   - Элементы не поддерживают хеширование
   - Нужна предсказуемая производительность

## Особенности реализации

```cpp
// Пример структуры хеш-таблицы
template<typename T>
class HashTable {
    struct Node {
        T data;
        Node* next;
    };
    
    std::vector<Node*> buckets;
    size_t size;
    
    size_t hash(const T& value) const {
        return std::hash<T>{}(value) % buckets.size();
    }
    
public:
    void insert(const T& value) {
        size_t index = hash(value);
        Node* newNode = new Node{value, buckets[index]};
        buckets[index] = newNode;
        size++;
        
        // Рехеширование при необходимости
        if (size > buckets.size() * 0.75) {
            rehash();
        }
    }
    
    void rehash() {
        std::vector<Node*> newBuckets(buckets.size() * 2);
        // Перехеширование элементов
        // ...
    }
};
``` 