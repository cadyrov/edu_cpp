# Как использовать cbegin() и cend()?

## Вопрос
Как использовать `cbegin()` и `cend()`?

## Ответ
`cbegin()` и `cend()` - это методы контейнеров STL, которые возвращают константные итераторы:
- `cbegin()` возвращает константный итератор на первый элемент
- `cend()` возвращает константный итератор на позицию после последнего элемента

## Примеры кода

### Правильное использование
```cpp
#include <vector>
#include <list>
#include <iostream>

int main() {
    // Использование с vector
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // Обход с использованием константных итераторов
    for (auto it = vec.cbegin(); it != vec.cend(); ++it) {
        std::cout << *it << " "; // Можно читать значение
        // *it = 10; // Ошибка компиляции: нельзя изменять значение через константный итератор
    }
    std::cout << std::endl;

    // Использование с const контейнером
    const std::list<int> lst = {1, 2, 3, 4, 5};
    for (auto it = lst.cbegin(); it != lst.cend(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // Использование в алгоритмах
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    auto it = std::find(numbers.cbegin(), numbers.cend(), 3);
    if (it != numbers.cend()) {
        std::cout << "Found: " << *it << std::endl;
    }

    return 0;
}
```

### Неправильное использование
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    
    // ❌ Неправильно: попытка изменить значение через константный итератор
    auto it = vec.cbegin();
    *it = 10; // Ошибка компиляции: нельзя изменять значение через константный итератор
    
    // ❌ Неправильно: использование константного итератора для неконстантного контейнера
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    auto cit = numbers.cbegin();
    numbers.push_back(6); // Инвалидирует итератор
    std::cout << *cit << std::endl; // Неопределенное поведение
    
    // ❌ Неправильно: смешивание константных и неконстантных итераторов
    auto it1 = vec.begin();
    auto cit1 = vec.cbegin();
    if (it1 == cit1) { // Ошибка компиляции: разные типы итераторов
        std::cout << "Equal" << std::endl;
    }
    
    return 0;
}
```

## Комментарии
1. Константные итераторы гарантируют, что элементы не будут изменены
2. `cbegin()/cend()` особенно полезны при работе с константными контейнерами
3. Константные итераторы могут быть использованы в алгоритмах, которые только читают данные
4. При использовании `auto` с константными итераторами тип будет выведен как `const_iterator`
5. Константные итераторы могут быть инвалидированы при изменении контейнера
6. В современном C++ предпочтительнее использовать `const auto&` в range-based for loop
7. Константные итераторы обеспечивают безопасность при работе с данными
8. При работе с константными итераторами компилятор предотвращает случайное изменение данных 