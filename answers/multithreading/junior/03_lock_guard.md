# Что такое `lock_guard`?

`std::lock_guard` - это RAII-обертка для мьютекса, которая автоматически блокирует мьютекс при создании и разблокирует его при уничтожении.

## Основные характеристики:
- Гарантирует освобождение мьютекса даже при возникновении исключений
- Нельзя разблокировать мьютекс вручную
- Нельзя копировать или перемещать
- Простой и безопасный способ работы с мьютексами

## Пример использования:

```cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex mtx;
int sharedData = 0;

void increment() {
    for (int i = 0; i < 1000; ++i) {
        std::lock_guard<std::mutex> lock(mtx);
        sharedData++;
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    
    t1.join();
    t2.join();
    
    std::cout << "Final value: " << sharedData << std::endl;
    return 0;
}
```

## Как правильно использовать:
1. Используйте для простых случаев блокировки
2. Создавайте в минимально необходимой области видимости
3. Используйте для защиты небольших критических секций
4. Комбинируйте с другими примитивами синхронизации

## Как НЕ надо использовать:
```cpp
// ❌ Неправильно: Слишком большая область видимости
{
    std::lock_guard<std::mutex> lock(mtx);
    // Много кода вне критической секции
    std::cout << "Some non-critical work" << std::endl;
    sharedData++; // Только эта операция требует синхронизации
}

// ❌ Неправильно: Попытка ручного управления блокировкой
std::lock_guard<std::mutex> lock(mtx);
lock.unlock(); // Ошибка компиляции - нельзя разблокировать вручную

// ❌ Неправильно: Создание в глобальной области
std::mutex mtx;
std::lock_guard<std::mutex> globalLock(mtx); // Неправильно - блокировка на всю жизнь программы
```

## Комментарии:
- lock_guard - самый простой и безопасный способ работы с мьютексами
- Для более сложных сценариев используйте unique_lock
- Не используйте для случаев, требующих условной блокировки
- Хорошо подходит для защиты небольших критических секций 